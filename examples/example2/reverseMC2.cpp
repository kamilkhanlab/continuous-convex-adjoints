#include "reverseMC2.hpp"              /* access to Reverse mode of subgradient evaluations */
/*
* Reverse mode of automatic differentiation
* Computations of df/dx required by evaluating fB
*/
N_Vector fRevAD_dfdx(MC xMC[NX], MC pMC[NP], double sub[NRev * NRev], int n, int k)
{
    SUNContext sunctx;
    SUNContext_Create(NULL, &sunctx);
    RevMC vBar[L];
    MC v[L];
    N_Vector adcvcc = N_VNew_Serial(NRev * NX, sunctx);
    for (int j = 0; j < NRev * NX; j++) 
    {
        Ith(adcvcc, j + 1) = 0;
    }

    double** vsub = new double*[L];
    for(int i = 0; i < L; i++) {
        vsub[i] = new double[NRev * 2];
    }

    
    /*
    *-----------------------------------------------------------------
    * The following code was automatically generated by ReverseADforVW.jl.
    *-----------------------------------------------------------------
    */ 
            
    switch (n)
    { 

    case 0:
        v[0] = xMC[0];
        v[1] = pMC[0];
        v[0].sub(NRev, &sub[0+k], &sub[0+k]);
        v[2] = pow(v[0], 2);

        for (int i = 0; i < NRev; i++)
        {
           vsub[2][i] = v[2].cvsub(i);
           vsub[2][NRev + i] = v[2].ccsub(i);
        }
    
        v[3] = 1.0;
        v[2].sub(NRev, &sub[0], &sub[4]);

        v[4] = v[2] - v[3];

        for (int i = 0; i < NRev; i++)
        {
           vsub[4][i] = v[4].cvsub(i);
           vsub[4][NRev + i] = v[4].ccsub(i);
        }
    

        v[4].sub(NRev, &sub[8], &sub[12]);
        v[5] = v[1] * v[4];

        for (int i = 0; i < NRev; i++)
        {
           vsub[5][i] = v[5].cvsub(i);
           vsub[5][NRev + i] = v[5].ccsub(i);
        }
    
        //-----------------------------------------------------------------------
        // Evaluate subgradients with reverse sweep through computational graph

        for (int i = 0; i < L1; i++)
        {
            //vBar[i] = RevMC(v[i]);
            if (i == L1 - 1)
            {
                double Sub[NRev] = {1,0,0,1};
                vBar[i].subbar(NRev/2, &Sub[0], &Sub[2]);
            }
            else
            {
                vBar[i].subbar(NRev/2);
            }
        }

        vBar[1] = vBar[1] + vBar[5] * tmpv(vsub[5], 1);
        vBar[4] = vBar[4] + vBar[5] * tmpv(vsub[5], 2);
        vBar[2] = vBar[2] + vBar[4] * tmpv(vsub[4], 1);
        vBar[3] = vBar[3] + vBar[4] * tmpv(vsub[4], 2);
        vBar[0] = vBar[0] + vBar[2] * tmpv(vsub[2], 1);
    
        break;       

    }
    
    for (int j = 0; j < NX; j++)
    {
        for (int i = 0; i < NRev/2; i++)
        {
            Ith(adcvcc, 2 * j + i + 1) = vBar[j].cvsubbar(i);
            Ith(adcvcc, 2 * NX + 2 * j + i + 1) = vBar[j].ccsubbar(i);
        }
    }
    
    for(int i = 0; i < L; i++) {
        delete[] vsub[i];
    }
    delete[] vsub;
    
    SUNContext_Free(&sunctx);
    return adcvcc;
    
}

/*
* Reverse mode of automatic differentiation
* Computations of df/dp required by evaluating fQB
*/
N_Vector fRevAD_dfdp(MC xMC[NX], MC pMC[NP], double sub[NRev * NRev], int n)
{
    SUNContext sunctx;
    SUNContext_Create(NULL, &sunctx);
    RevMC vBar[L];
    MC v[L];
    N_Vector adcvcc = N_VNew_Serial(NRev/2 * NP, sunctx);
    for (int j = 0; j < NRev/2 * NP; j++) 
    {
        Ith(adcvcc, j + 1) = 0;
    }

    double** vsub = new double*[L];
    for(int i = 0; i < L; i++) {
        vsub[i] = new double[NRev * 2];
    }

    
    /*
    *-----------------------------------------------------------------
    * The following code was automatically generated by ReverseADforVW.jl.
    *-----------------------------------------------------------------
    */ 
            
    switch (n)
    { 

    case 0:
        v[0] = xMC[0];
        v[1] = pMC[0];

        v[2] = pow(v[0], 2);

        for (int i = 0; i < NRev; i++)
        {
            vsub[2][i] = v[2].cvsub(i);
            vsub[2][NRev + i] = v[2].ccsub(i);
        }
    
        v[3] = 1.0;
        v[2].sub(NRev, &sub[0], &sub[4]);

        v[4] = v[2] - v[3];

        for (int i = 0; i < NRev; i++)
        {
            vsub[4][i] = v[4].cvsub(i);
            vsub[4][NRev + i] = v[4].ccsub(i);
        }
    
        v[1].sub(NRev, &sub[0], &sub[4]);
        v[4].sub(NRev, &sub[8], &sub[12]);
        v[5] = v[1] * v[4];

        for (int i = 0; i < NRev; i++)
        {
            vsub[5][i] = v[5].cvsub(i);
            vsub[5][NRev + i] = v[5].ccsub(i);
        }
    
        //-----------------------------------------------------------------------
        // Evaluate subgradients with a reverse sweep through the computational graph

        for (int i = 0; i < L1; i++)
        {
            //vBar[i] = RevMC(v[i]);
            if (i == L1 - 1)
            {
                double Sub[NRev] = {1,0,0,1};
                vBar[i].subbar(NRev/2, &Sub[0], &Sub[2]);
            }
            else
            {
                vBar[i].subbar(NRev/2);
            }
        }

        vBar[1] = vBar[1] + vBar[5] * tmpv(vsub[5], 1);
        vBar[4] = vBar[4] + vBar[5] * tmpv(vsub[5], 2);
        vBar[2] = vBar[2] + vBar[4] * tmpv(vsub[4], 1);
        vBar[3] = vBar[3] + vBar[4] * tmpv(vsub[4], 2);
        vBar[0] = vBar[0] + vBar[2] * tmpv(vsub[2], 1);
    
        break;       

    }
    
    for (int j = 0; j < NP; j++)
    {
        Ith(adcvcc, j + 1) = vBar[j + NX].cvsubbar(0) + vBar[j + NX].cvsubbar(1);
        Ith(adcvcc, NP + j + 1) = vBar[j + NX].ccsubbar(0) + vBar[j + NX].ccsubbar(1);
    }
    
    for(int i = 0; i < L; i++) {
        delete[] vsub[i];
    }
    delete[] vsub;
    
    SUNContext_Free(&sunctx);
    return adcvcc;
    
}

/*
* Generate tmpcv/tmpcc values in the forward sweep
*/
MC tmpv(double* vsub, int i)
{
    MC MC1;
    MC1.sub(NRev/2, &vsub[(i - 1) * 2], &vsub[(i - 1) * 2 + 4]);
    return MC1;
}

